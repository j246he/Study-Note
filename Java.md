## 向下转型

short占据16位，int占据32位，float占据32位，double占据64位

不能隐式执行向下转型，这样会使精度降低。

```java
float f = 1.1; //错误
```

```java
float f = 1.1f; //正确
```

```java
short s1 = 1; //错误，short精度低，int精度高，不能直接转换
```

```java
s1 += 1; //正确，隐式类型转换
//相当于
s1 = (short)(s1+1); 
```

## static、final、static final

### final: 

修饰的属性标明是一个常数（创建后不能被修改），修饰的方法表示该方法在子类中不能被重写，修饰的类表示该类不能被继承。

对于对象句柄（引用或指针），会将句柄变为一个常数，句柄不能指向另一个对象，但是对象本身可以修改（包括数组，数组也是对象）。对于方法参数中的final句柄，在方法内部，该参数句柄不能改变指向，也就是方法内部不能给形参句柄再另外赋值。

### static

与具体对象无关，不创建对象也可以调用static修饰的属性和方法。不可以修饰局部变量。修饰的属性所有对象都只有一个值，强调只有一个。

### static final

static强调只有一个，final表明是一个常数。

static final修饰值时表示一旦给值，就不可修改，并且可以通过类名访问。

static final修饰方法时表示该方法不能重写，可以在不new对象的情况下调用。

## 接口与抽象类

### 抽象类

如果一个类中包含抽象方法，那么这个类必须声明为抽象类。

抽象类与普通类最大的区别是：抽象类不能被实例化，需要继承抽象类才能实例化其子类。

#### 为什么要有抽象类？

父类是动物或者汽车时，这些抽象的东西是没有一个具体的实例的，所以不能被抽象化。

### 比较

- 接口：LIKE-A；抽象类：IS-A。

- 一个类可以实现多个接口，但是不能继承多个抽象类。

  （为什么类不能多继承？）

  （因为如果两个父类中含有相同名字的属性或者方法，子类调用时会混淆。）

- 接口字段只能是static和final类型的，而抽象类的字段没有这种限制。

- 接口成员只能是public的，抽象类成员可以有多种访问限制。

### 使用选择

使用接口：

- 需要多重继承
- 需要让不相关的类都实现一个方法

使用抽象类：

- 需要在几个相关的类中共享代码
- 需要能控制继承来的成员的访问权限，而不是都为public
- 需要继承非static和final（非静态、非常量）的字段。

## super

访问父类的构造函数：可以使用super()函数访问父类的构造函数，从而委托父类完成一些初始化的工作。

访问父类的成员：如果子类重写了父类的某个方法，可以通过super关键字调用父类的方法实现。

（里氏替换原则：父类出现的地方子类一定可以进行替换。理解：父类可以使用的地方，子类一定有该方法，或继承或重写，子类的方法在此可以替换父类。但子类出现的地方，父类不一定有该方法。）

## 重写

调用方法时，先从本类中查找是否有对应的方法，如果没有，去查找父类是否有对应方法，否则才采用参数转型。

优先级：

```java
this.func(this)

super.func(this)

this.func(super)

super.func(super)
```

```java
//A是父类，B是子类
A a = new B ()
//实际还是B类对象
```

## 重载

方法名称相同，但是参数类型、个数、顺序至少有一个不同。只有返回值不同，不是重载。

## hashCode()

每个域当成R进制的某一位，然后组成R进制的整数，R一般取31。

为什么选择31？

1. 因为它是奇数。偶数相当与×2进行左移，当乘法溢出时，后位补的都是零，造成信息丢失，导致hashcode一样的概率变大，而奇数有意让hash值最大程度散布，降低碰撞可能。
2. 因为它可以简化为(x<<5)-x for better performance。

## 拷贝clone

### 浅拷贝shallow clone

```java
shallowExp e1 = new shallowCloneExp();
shallowExp e2 = null;
e1.set(2,222);//给这个array的index=2的元素赋值222
System.out.printIn(e2.get(2));//222
```

浅拷贝是对象和原始对象的引用类型引用同一个对象。

### 深拷贝deep clone

深拷贝是对象和原始对象的引用类型引用不同对象。

